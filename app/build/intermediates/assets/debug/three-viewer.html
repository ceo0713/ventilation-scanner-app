<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a1a;
        }
        #container {
            width: 100%;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <div id="status">3D Viewer 로딩 중...</div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        let scene, camera, renderer, controls;
        let roomMesh, arrowHelpers = [];
        let visualizationObjects = [];
        let beforeData = null, afterData = null;
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(3, 3, 3);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);
            
            const gridHelper = new THREE.GridHelper(10, 10);
            scene.add(gridHelper);
            
            const axesHelper = new THREE.AxesHelper(2);
            scene.add(axesHelper);
            
            window.addEventListener('resize', onWindowResize);
            
            animate();
            
            document.getElementById('status').textContent = '3D Viewer 준비 완료';
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function loadRoom(meshData) {
            if (roomMesh) {
                scene.remove(roomMesh);
                roomMesh.geometry.dispose();
                roomMesh.material.dispose();
            }
            
            const vertices = meshData.vertices;
            const faces = meshData.faces;
            
            const geometry = new THREE.BufferGeometry();
            
            const positions = [];
            for (const face of faces) {
                positions.push(...vertices[face[0]]);
                positions.push(...vertices[face[1]]);
                positions.push(...vertices[face[2]]);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshPhongMaterial({
                color: 0x4488ff,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide,
                wireframe: false
            });
            
            roomMesh = new THREE.Mesh(geometry, material);
            scene.add(roomMesh);
            
            const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1 });
            const wireframeGeometry = new THREE.WireframeGeometry(geometry);
            const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
            roomMesh.add(wireframe);
            
            const box = new THREE.Box3().setFromObject(roomMesh);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            camera.position.set(
                center.x + size.x,
                center.y + size.y,
                center.z + size.z
            );
            camera.lookAt(center);
            controls.target.copy(center);
            
            document.getElementById('status').textContent = 
                `공간 로드 완료 (${(size.x).toFixed(2)}m × ${(size.y).toFixed(2)}m × ${(size.z).toFixed(2)}m)`;
        }
        
        function visualizeAirflow(velocityData) {
            clearVisualization();
            
            const gridWidth = velocityData.gridWidth;
            const gridHeight = velocityData.gridHeight;
            const ux = velocityData.ux;
            const uy = velocityData.uy;
            
            if (!roomMesh) return;
            
            const box = new THREE.Box3().setFromObject(roomMesh);
            const size = box.getSize(new THREE.Vector3());
            const min = box.min;
            
            const stepX = Math.max(1, Math.floor(gridWidth / 30));
            const stepY = Math.max(1, Math.floor(gridHeight / 30));
            
            let count = 0;
            for (let y = 0; y < gridHeight; y += stepY) {
                for (let x = 0; x < gridWidth; x += stepX) {
                    const idx = y * gridWidth + x;
                    const mag = Math.sqrt(ux[idx]**2 + uy[idx]**2);
                    if (mag > 0.005) count++;
                }
            }
            
            const coneGeo = new THREE.ConeGeometry(0.03, 0.12, 6);
            coneGeo.rotateX(Math.PI / 2);
            const material = new THREE.MeshPhongMaterial({ vertexColors: false });
            const instancedMesh = new THREE.InstancedMesh(coneGeo, material, count);
            
            const dummy = new THREE.Object3D();
            const color = new THREE.Color();
            let i = 0;
            
            for (let y = 0; y < gridHeight; y += stepY) {
                for (let x = 0; x < gridWidth; x += stepX) {
                    const idx = y * gridWidth + x;
                    const vx = ux[idx];
                    const vy = uy[idx];
                    const mag = Math.sqrt(vx**2 + vy**2);
                    if (mag <= 0.005) continue;
                    
                    const worldX = min.x + (x/gridWidth)*size.x;
                    const worldY = min.y + size.y*0.5;
                    const worldZ = min.z + (y/gridHeight)*size.z;
                    
                    dummy.position.set(worldX, worldY, worldZ);
                    dummy.lookAt(worldX + vx, worldY, worldZ + vy);
                    dummy.scale.setScalar(Math.min(mag * 5, 1.5));
                    dummy.updateMatrix();
                    instancedMesh.setMatrixAt(i, dummy.matrix);
                    
                    color.setHSL(0.7 - Math.min(mag, 0.5), 1.0, 0.5);
                    instancedMesh.setColorAt(i, color);
                    i++;
                }
            }
            
            instancedMesh.instanceMatrix.needsUpdate = true;
            if (instancedMesh.instanceColor) instancedMesh.instanceColor.needsUpdate = true;
            scene.add(instancedMesh);
            visualizationObjects.push(instancedMesh);
            
            document.getElementById('status').textContent = 
                `기류 시각화 완료 (화살표 ${count}개)`;
        }
        
        function clearArrows() {
            arrowHelpers.forEach(arrow => {
                scene.remove(arrow);
            });
            arrowHelpers = [];
        }
        
        function clearVisualization() {
            visualizationObjects.forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            visualizationObjects = [];
            clearArrows();
        }
        
        function visualizeDeadZones(deadZoneData, velocityData) {
            if (!roomMesh || !deadZoneData || !deadZoneData.map) return;
            
            const box = new THREE.Box3().setFromObject(roomMesh);
            const size = box.getSize(new THREE.Vector3());
            const min = box.min;
            
            const gridWidth = velocityData.gridWidth;
            const gridHeight = velocityData.gridHeight;
            const cellSizeX = size.x / gridWidth;
            const cellSizeZ = size.z / gridHeight;
            
            const geometry = new THREE.BoxGeometry(cellSizeX, size.y * 0.8, cellSizeZ);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.3
            });
            
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const idx = y * gridWidth + x;
                    if (deadZoneData.map[idx] === 1) {
                        const worldX = min.x + (x + 0.5) / gridWidth * size.x;
                        const worldY = min.y + size.y * 0.5;
                        const worldZ = min.z + (y + 0.5) / gridHeight * size.z;
                        
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(worldX, worldY, worldZ);
                        scene.add(mesh);
                        visualizationObjects.push(mesh);
                    }
                }
            }
            
            document.getElementById('status').textContent = 
                `데드존 시각화 완료 (${deadZoneData.percentage.toFixed(1)}%)`;
        }
        
        function visualizeConcentration(concentrationData, velocityData) {
            if (!roomMesh || !concentrationData) return;
            
            const box = new THREE.Box3().setFromObject(roomMesh);
            const size = box.getSize(new THREE.Vector3());
            const min = box.min;
            
            const gridWidth = velocityData.gridWidth;
            const gridHeight = velocityData.gridHeight;
            
            const canvas = document.createElement('canvas');
            canvas.width = gridWidth;
            canvas.height = gridHeight;
            const ctx = canvas.getContext('2d');
            
            const imageData = ctx.createImageData(gridWidth, gridHeight);
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const idx = y * gridWidth + x;
                    const c = concentrationData[idx] || 0;
                    const pixelIdx = (y * gridWidth + x) * 4;
                    
                    const r = Math.floor(Math.min(c * 2, 1) * 255);
                    const g = Math.floor(Math.max(0, 1 - c * 2) * 255);
                    
                    imageData.data[pixelIdx] = r;
                    imageData.data[pixelIdx + 1] = g;
                    imageData.data[pixelIdx + 2] = 0;
                    imageData.data[pixelIdx + 3] = 128;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            
            const texture = new THREE.CanvasTexture(canvas);
            const geometry = new THREE.PlaneGeometry(size.x, size.z);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            
            const plane = new THREE.Mesh(geometry, material);
            plane.rotation.x = -Math.PI / 2;
            plane.position.set(
                min.x + size.x / 2,
                min.y + size.y * 0.5,
                min.z + size.z / 2
            );
            scene.add(plane);
            visualizationObjects.push(plane);
            
            document.getElementById('status').textContent = '바이러스 농도 시각화 완료';
        }
        
        function addDeviceMarkers(devices) {
            if (!devices || !Array.isArray(devices)) return;
            
            devices.forEach(device => {
                const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const color = getDeviceColor(device.type);
                const material = new THREE.MeshPhongMaterial({ color: color });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(device.x, device.y, device.z);
                scene.add(mesh);
                visualizationObjects.push(mesh);
                
                if (device.type === 'AIR_STERILIZER' && device.radius) {
                    const circleGeo = new THREE.RingGeometry(device.radius - 0.05, device.radius, 32);
                    const circleMat = new THREE.MeshBasicMaterial({
                        color: 0xff1744,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    });
                    const circle = new THREE.Mesh(circleGeo, circleMat);
                    circle.rotation.x = -Math.PI / 2;
                    circle.position.set(device.x, device.y - 0.1, device.z);
                    scene.add(circle);
                    visualizationObjects.push(circle);
                }
            });
        }
        
        function getDeviceColor(type) {
            const colors = {
                'DOOR': 0x4caf50,
                'WINDOW': 0x2196f3,
                'VENT': 0xff9800,
                'AC_UNIT': 0x00bcd4,
                'VENTILATOR': 0x9c27b0,
                'AIR_PURIFIER': 0x8bc34a,
                'AIR_STERILIZER': 0xe91e63
            };
            return colors[type] || 0xffffff;
        }
        
        function setBeforeAfterData(before, after) {
            beforeData = before;
            afterData = after;
        }
        
        function showBefore() {
            if (beforeData) {
                clearVisualization();
                visualizeAirflow(beforeData.velocityField);
                document.getElementById('status').textContent = 'Before 상태 표시 중';
            }
        }
        
        function showAfter() {
            if (afterData) {
                clearVisualization();
                visualizeAirflow(afterData.velocityField);
                document.getElementById('status').textContent = 'After 상태 표시 중';
            }
        }
        
        function addOpening(opening) {
            const geometry = new THREE.BoxGeometry(
                opening.width || 0.2,
                opening.height || 0.2,
                0.1
            );
            
            const color = opening.type === 'inlet' ? 0x00ff00 : 0xff0000;
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.7
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(opening.x, opening.y, opening.z);
            scene.add(mesh);
        }
        
        window.init = init;
        window.loadRoom = loadRoom;
        window.visualizeAirflow = visualizeAirflow;
        window.clearArrows = clearArrows;
        window.clearVisualization = clearVisualization;
        window.addOpening = addOpening;
        window.visualizeDeadZones = visualizeDeadZones;
        window.visualizeConcentration = visualizeConcentration;
        window.addDeviceMarkers = addDeviceMarkers;
        window.setBeforeAfterData = setBeforeAfterData;
        window.showBefore = showBefore;
        window.showAfter = showAfter;
        
        init();
    </script>
</body>
</html>
